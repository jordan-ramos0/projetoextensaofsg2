<!DOCTYPE html>
<html lang="pt-BR" style="height:100%">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Aprendendo Sobre Saúde - FSG</title>
<style>
html,body{margin:0;padding:0;height:100%;width:100%;font-family:system-ui,-apple-system,"Segoe UI",Roboto,"Helvetica Neue",Arial;background:#fafafa;}
header{position:fixed;top:0;left:0;right:0;height:60px;background:rgb(60,57,107);color:#fff;display:flex;align-items:center;justify-content:space-between;padding:0 12px;z-index:1000;box-shadow:0 2px 5px rgba(0,0,0,.15);}
#menuToggle{font-size:22px;line-height:1;color:#fff;cursor:pointer;user-select:none;display:block;}
#hub{display:flex; flex-direction: column;position:fixed;top:60px;left:0;width:230px;bottom:0;background:rgba(245,245,245,.98);overflow-y:auto;z-index:1600;transform:translateX(-200px);transition:transform .22s ease;box-shadow:2px 0 6px rgba(0,0,0,.12);}
#hub.open{transform:translateX(0);}
#hub ul{list-style:none;margin:0;padding:0;}
#hub li{padding:12px 10px;cursor:pointer;border-bottom:1px solid #e6e6e6;}
#hub li.hovered,#hub li:hover,#hub li:focus{background:#e9e9e9;outline:none;}
#content{position:relative;top:60px;box-sizing:border-box;height:calc(100vh - 60px);overflow-y:auto;overflow-x:hidden;background:#fafafa;touch-action:none;}
canvas.page-canvas{display:block;background:#fff;}
#zoomControls{position:fixed;right:18px;bottom:18px;z-index:1600;display:flex;flex-direction:column;gap:8px;}
#zoomControls button{border:0;background:#39496b;color:#fff;padding:10px 12px;border-radius:8px;font-size:18px;cursor:pointer;touch-action:manipulation;}
#zoomControls button:active{transform:scale(.98);}
#tapStrip{position:fixed;top:60px;left:0;width:30px;height:calc(100vh - 60px);z-index:1700;}
/* ADDED: bullet element styling */
#hub li { position: relative; display: flex; align-items: center; justify-content: space-between; }
#hub li .bullet { width: 9px; height: 9px; transition: all 0.2s ease; flex-shrink: 0; border-radius: 35%; }
#hub li.active .bullet { box-shadow: 0 0 0 2px rgba(0, 88, 170, 0.904); }
#hub.open ~ #tapStrip, #hub.open ~ #zoomControls { display: none; }
* { user-select: none; -webkit-user-select: none; -moz-user-select: none; -ms-user-select: none; }
#pdfList { flex: 1 1 auto; overflow-y: auto; margin: 0; padding: 0; list-style: none; scrollbar-width: none; -ms-overflow-style: none; }
#hub::-webkit-scrollbar { display: none; }
#content { scrollbar-width: none; -ms-overflow-style: none; }
#content::-webkit-scrollbar { display: none; }
#reviewLi { flex-shrink: 0; background: #FFD700; color: #000; padding: 20px 10px; text-align: center; cursor: pointer; box-shadow: 0 -2px 6px rgba(0,0,0,0.15); }
/* ADDED: bullet element styling */
#hub li {
  position: relative;
  display: flex;
  align-items: center;
  justify-content: space-between;
}

#hub li .bullet {
  width: 9px;
  height: 9px;
  transition: all 0.2s ease;
  flex-shrink: 0;
  border-radius: 35%;
}

#hub li.active .bullet {

  box-shadow: 0 0 0 2px rgba(0, 88, 170, 0.904);
}
#hub.open ~ #tapStrip,
#hub.open ~ #zoomControls {
  display: none;
}

</style>
</head>
<body>
<header>
<h1 style="font-size:18px;margin:0;color:#fff;">Aprendendo Sobre Saúde - FSG</h1>
<div id="menuToggle" aria-label="Abrir menu" role="button" tabindex="0">☰</div>
</header>

<div  id="hub" aria-hidden="true"><ul  id="pdfList" aria-label="Lista de PDFs"></ul></div>
<style>
* {
  user-select: none;        /* standard */
  -webkit-user-select: none; 
  -moz-user-select: none;    
  -ms-user-select: none;     
}

#hub {
  position: fixed;

  top: 60px;
  left: 0;
  bottom: 0;
  width: 230px;
  background: rgba(245,245,245,.98);
  display: flex;
  flex-direction: column;
  /* remove overflow-y:auto from hub */
}
canvas {
  margin:0px;
}
#pdfList {
  flex: 1 1 auto;
  overflow-y: auto;
  margin: 0;
  padding: 0;
  list-style: none;
  scrollbar-width: none;    /* Firefox */
  -ms-overflow-style: none;
}

#reviewLi {
  flex-shrink: 0;
  background: #FFD700;
  color: #000;
  padding: 20px 10px;
  text-align: center;
  cursor: pointer;
  box-shadow: 0 -2px 6px rgba(0,0,0,0.15);
}
#hub::-webkit-scrollbar {
  display: none;           /* Chrome/Safari */
}

</style>
<script>

const reviewLi = document.createElement('li');
reviewLi.textContent = 'Clique aqui para nos avaliar!';
reviewLi.tabIndex = 0;
reviewLi.style.cssText = `
  background: #FFD700;
  color: #000;
  padding: 40px 10px;
  cursor: pointer;
  text-align: center;
  z-index: 2000;
  box-shadow: 0 -2px 6px rgba(0,0,0,0.15);
`;


// Create the star bullet (same concept as other bullets)
const starBullet = document.createElement('span');
starBullet.className = 'bullet';
starBullet.textContent = '★';
starBullet.style.cssText = `
  font-size: 20px;
  color: #fff;
  display: inline-flex;
  align-items: center;
  justify-content: center;
  width: 14px;
  height: 14px;
  flex-shrink: 0;
`;

// Add star bullet before the text
reviewLi.appendChild(starBullet, reviewLi.firstChild);


hub.appendChild(reviewLi);

// Popup overlay
const reviewPopup = document.createElement('div');
reviewPopup.style.cssText = `
  position: fixed;
  top: 0; left: 0; right: 0; bottom: 0;
  background: rgba(0,0,0,0.5);
  display: none;
  justify-content: center;
  align-items: center;
  z-index: 3000;
`;

// Card inside popup
const card = document.createElement('div');
card.style.cssText = `
  position: relative;
  background: #fff;
  padding: 20px;
  padding-top: 50px;
  border-radius: 10px;
  width: 90vw;        
  max-width: 400px;   /* cap on desktop */
  box-sizing: border-box;
  display: flex;
  flex-direction: column;
  gap: 10px;
`;


// Blue "X" at top-right
const closeX = document.createElement('span');
closeX.innerHTML = '✖';
closeX.style.cssText = `
  position: absolute;
  top: 4px;
  right: 4px;
  font-size: 42px;
  line-height: 0.8;
  cursor: pointer;
  color: #39496b;
  user-select: none;
  z-index: 10;
`;
closeX.id = "closeEvalBut"
card.appendChild(closeX);


const starCount = 5; const starStyle = 'class="star" style="font-size:48px;color:#ccc;cursor:pointer;line-height:0.75;user-select:none;" ';

const formHTML = `
  <p> Avalie o projeto </p>
  <input type="text" placeholder="Seu nome" style="padding:6px;border-radius:4px;border:1px solid #ccc;width:100%;box-sizing:border-box;">
  <textarea placeholder="Comentário (opcional)" style="resize:vertical"></textarea>
  <div style="display:flex;gap:10px;margin-top:0px; justify-content:center;">
    ${Array(starCount).fill(`<span ${starStyle}>★</span>`).join('')}
  </div>
  <div style="display:flex;justify-content:flex-end;gap:8px;margin-top:10px;">
    <button id="cancelBtn" style="padding:8px 12px;border:none;border-radius:4px;background:#ccc;color:#000;cursor:pointer;">Cancelar</button>
    <button id="sendBtn" style="padding:8px 12px;border:none;border-radius:4px;background:#39496b;color:#fff;cursor:pointer;">Enviar</button>
  </div>
`;
card.innerHTML += formHTML;
reviewPopup.appendChild(card);
document.body.appendChild(reviewPopup);


const stars = card.querySelectorAll('.star');
let currentRating = 0;

stars.forEach((star, idx) => {
  star.dataset.value = idx + 1;
  star.addEventListener('click', () => {
    currentRating = idx + 1;
    stars.forEach((s, i) => {
      s.style.color = i < currentRating ? '#FFD700' : '#ccc';
    });
  });
});

// Show popup
reviewLi.addEventListener('click', () => reviewPopup.style.display = 'flex');

// Close popup
document.getElementById('closeEvalBut').addEventListener('click', () => reviewPopup.style.display = 'none');
document.getElementById('cancelBtn').addEventListener('click', () => reviewPopup.style.display = 'none');
document.getElementById('sendBtn').addEventListener('click', () => {
  // Close popup
  

  // Reset stars/input
  stars.forEach(s => s.style.color = '#ccc');
  currentRating = 0;
  card.querySelector('input').value = '';
  card.querySelector('textarea').value = '';

// Create toast
(() => {
  const t = document.createElement('div');
  t.textContent = 'Avaliação enviada!';
  Object.assign(t.style,{position:'fixed',top:'50%',left:'50%',transform:'translate(-50%,-50%)',background:'#39496b',color:'#fff',padding:'10px 16px',borderRadius:'8px',boxShadow:'0 2px 6px rgba(0,0,0,0.2)',opacity:'1',transition:'opacity 2s linear',zIndex:'4000',pointerEvents:'none',fontFamily:'sans-serif'});
  document.body.appendChild(t);
  void t.offsetWidth; // force reflow to trigger transition
  t.style.opacity='0';
  setTimeout(() => t.remove(),2000);
})();
setTimeout(() => reviewPopup.style.display = 'none', 1000);


});


  </script>
  



<div id="tapStrip"></div>
<div id="content" aria-live="polite"></div>
<div id="zoomControls" aria-hidden="false">
<button display="none" id="zoomIn" aria-label="Aumentar zoom">＋</button>
<button display="none" id="zoomOut" aria-label="Diminuir zoom">−</button>
</div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.6.347/pdf.min.js"></script>
<script>
pdfjsLib.GlobalWorkerOptions.workerSrc = "https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.6.347/pdf.worker.min.js";


const pdfIndexData = [
  { title: "Atividades físicas saúde mental e bem estar", color: "#1E8449", desktop: "pdfs/julialemesPC.pdf", mobile: "pdfs/julialemesCEL.pdf" },
  { title: "Doenças Sazonais e de Baixo Risco", color: "#2471A3", desktop: "pdfs/Doenças SazonaisPC.pdf", mobile: "pdfs/Doenças SazonaisCEL.pdf" },
  { title: "Saúde Preventiva", color: "#D4AC0D", desktop: "pdfs/Saúde preventivaPC.pdf", mobile: "pdfs/Saúde PreventivaCEL.pdf" },
  { title: "Informações sobre a unidade basica de saúde", color: "#566573", desktop: "pdfs/CuidadosPC.pdf", mobile: "pdfs/CuidadosCel.pdf" },
  { title: "Doenças crônicas: conceito, exemplos, descoberta e tratamento", color: "#C0392B", desktop: "pdfs/DOENÇAS CRÔNICASPC.pdf", mobile: "pdfs/DOENÇAS CRÔNICASCEL.pdf" },
  { title: "Prevenção de doenças crônicas", color: "#CA6F1E", desktop: "pdfs/PrevençãodoençascronicasPC.pdf", mobile: "pdfs/PrevençãodoençascronicasCEL.pdf" },
  { title: "Apoio e rede de suporte para doenças crônicas", color: "#5B2C6F", desktop: "pdfs/apoiocronicaPC.pdf", mobile: "pdfs/apoiocronicaCEL.pdf" },
  //{ title: "Cuidados e orientações para familiares e cuidadores de idosos", color: "#148F77", desktop: "pdfs/Cuidados e Orientações para Familiares e Cuidadores de IdososPC.pdf", mobile: "Cuidados e Orientações para Familiares e Cuidadores de IdososCEL.pdf" },
];





const body=document.body, hub=document.getElementById('hub'), pdfList=document.getElementById('pdfList');
const content=document.getElementById('content'), menuToggle=document.getElementById('menuToggle');
const zoomInBtn=document.getElementById('zoomIn'), zoomOutBtn=document.getElementById('zoomOut');
const tapStrip=document.getElementById('tapStrip');

let currentPdfDoc=null, currentEntry=null, baseScale=null, zoomFactor=1, ZOOM_STEP=1.25;

/* Populate PDF list */
pdfIndexData.forEach(entry=>{
  const li=document.createElement('li');
  li.textContent=entry.title;
  li.tabIndex=0;
  
    /* ADDED: create colored bullet dynamically */
  const bullet=document.createElement('span');
  bullet.className='bullet';
  bullet.style.backgroundColor=entry.color || '#bbb';
  li.appendChild(bullet);


  // Always select entry on click
  li.addEventListener('click',()=>{
    selectEntry(entry);
    closeHub();
  });

  li.addEventListener('keydown',e=>{
    if(e.key==='Enter') li.click();
  });

  pdfList.appendChild(li);
});

/* Touch detection */
const hasTouch=('ontouchstart' in window)||(navigator.maxTouchPoints>0)||(navigator.msMaxTouchPoints>0);
if(hasTouch) body.classList.add('touch');

/* Sidebar open/close */
function openHub(){hub.classList.add('open');}
function closeHub(){hub.classList.remove('open');}
function toggleHub(){hub.classList.toggle('open');}

/* Desktop hover & click */
hub.addEventListener('mouseenter',()=>{if(!hasTouch) openHub();});
tapStrip.addEventListener('mouseenter',()=>{if(!hasTouch) openHub();});
hub.addEventListener('mouseleave',()=>{if(!hasTouch) closeHub();});
menuToggle.addEventListener('click',toggleHub);
menuToggle.addEventListener('keydown',e=>{if(e.key==='Enter') toggleHub();});

/* Mobile tap strip */
tapStrip.addEventListener('click',toggleHub);

/* Click outside closes hub */
document.addEventListener('click',ev=>{
  if(hub.contains(ev.target) || ev.target===menuToggle || ev.target===tapStrip) return;
  closeHub();
});

/* Helpers */
function getContentInnerWidth(){
  const style=getComputedStyle(content);
  return Math.max(1,content.clientWidth - (parseFloat(style.paddingLeft||0)+parseFloat(style.paddingRight||0)));
}
async function probeFirstPage(url){
  try{
    const loading=pdfjsLib.getDocument(url);
    const pdf=await loading.promise;
    const page=await pdf.getPage(1);
    const viewport=page.getViewport({scale:1});
    return {pdf,viewport};
  }catch(err){console.error('probe failed',url,err); return null;}
}



/* Select PDF entry */
async function selectEntry(entry) {
    // If the same PDF is already current, just scroll to it
    if (currentEntry === entry) {
        const firstCanvas = content.querySelector(`.page-canvas[data-pdf-index='${pdfIndexData.indexOf(entry)}']`);
        if (firstCanvas) {
            const targetScrollTop = firstCanvas.offsetTop - content.clientHeight / 2 + firstCanvas.clientHeight / 2 - 60;
            content.scrollTo({ top: targetScrollTop, behavior: "smooth" });
        }
        return; // STOP, don't re-render
    }

    currentEntry = entry;

    // Render new PDF
    const canvases = await renderPdfDocument(entry);
    const canvas = canvases[0];
    if (canvas) {
        const targetScrollTop = canvas.offsetTop - content.clientHeight / 2 + canvas.clientHeight / 2 - 130;
        content.scrollTo({ top: targetScrollTop, behavior: "smooth" });
    }
}

/* Render PDF pages */
async function renderPdfDocument(entry, { append = true } = {}) {
    const innerW = getContentInnerWidth();
    const innerH = content.clientHeight;

    const [desktopProbe, mobileProbe] = await Promise.all([
        entry.desktop ? probeFirstPage(entry.desktop) : null,
        entry.mobile ? probeFirstPage(entry.mobile) : null
    ]);

    let chosen = null;
    if (desktopProbe && mobileProbe) {
        const dh = innerW / desktopProbe.viewport.width * desktopProbe.viewport.height;
        const mh = innerW / mobileProbe.viewport.width * mobileProbe.viewport.height;
        chosen = (Math.abs(mh - innerH) < Math.abs(dh - innerH))
            ? { url: entry.mobile, probe: mobileProbe }
            : { url: entry.desktop, probe: desktopProbe };
        if (chosen.url === entry.mobile) try { desktopProbe.pdf.destroy(); } catch {} 
        else try { mobileProbe.pdf.destroy(); } catch {}
    } else if (desktopProbe) chosen = { url: entry.desktop, probe: desktopProbe };
    else if (mobileProbe) chosen = { url: entry.mobile, probe: mobileProbe };
    else return [];

    currentPdfDoc = chosen.probe.pdf;
    baseScale = (innerW - 0.5) / chosen.probe.viewport.width;

    const pdfIndex = pdfIndexData.indexOf(entry);
    const canvases = [];

    for (let p = 1; p <= currentPdfDoc.numPages; p++) {
        const page = await currentPdfDoc.getPage(p);
        const vp = page.getViewport({ scale: baseScale * zoomFactor });
        const canvas = document.createElement('canvas');
        canvas.className = 'page-canvas';
        canvas.dataset.pdfIndex = pdfIndex;
        canvas.width = Math.max(1, Math.round(vp.width));
        canvas.height = Math.max(1, Math.round(vp.height));
        canvas.style.margin = (canvas.width <= innerW + 0.5) ? '0 auto 10px auto' : '0 0 10px 0';
        const ctx = canvas.getContext('2d', { alpha: false });
        ctx.fillStyle = '#fff';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        await page.render({ canvasContext: ctx, viewport: vp }).promise;

        if (append) content.appendChild(canvas);
        canvases.push(canvas);
    }

    return canvases;
}


/* Zoom buttons */
zoomInBtn.addEventListener('click',()=>{zoomFactor*=ZOOM_STEP;if(currentPdfDoc) renderPdfDocument(currentPdfDoc);});
zoomOutBtn.addEventListener('click',()=>{zoomFactor/=ZOOM_STEP;if(zoomFactor<0.125) zoomFactor=0.125;if(currentPdfDoc) renderPdfDocument(currentPdfDoc);});

/* Resize debounce */
function debounce(fn,ms=200){let t;return(...a)=>{clearTimeout(t); t=setTimeout(()=>fn(...a),ms);};}
window.addEventListener('resize',debounce(()=>{if(currentEntry) selectEntry(currentEntry);},220));

/* Pinch-to-zoom */
if('PointerEvent' in window && hasTouch){
  let pointerMap=new Map(), pinchInitialDistance=null, pinchInitialZoom=null, pinchDebounce=null;
  const distance=(a,b)=>Math.hypot(a.x-b.x,a.y-b.y);
  const scheduleRender=()=>{if(pinchDebounce) return; pinchDebounce=setTimeout(()=>{pinchDebounce=null;if(currentPdfDoc) renderPdfDocument(currentPdfDoc);},60);}
  window.addEventListener('pointerdown',ev=>{if(ev.pointerType!=='touch') return; pointerMap.set(ev.pointerId,{x:ev.clientX,y:ev.clientY}); if(pointerMap.size===2){const pts=Array.from(pointerMap.values()); pinchInitialDistance=distance(pts[0],pts[1]); pinchInitialZoom=zoomFactor; ev.preventDefault && ev.preventDefault();}}, {passive:false});
  window.addEventListener('pointermove',ev=>{if(ev.pointerType!=='touch'||!pointerMap.has(ev.pointerId)) return; pointerMap.set(ev.pointerId,{x:ev.clientX,y:ev.clientY}); if(pointerMap.size===2 && pinchInitialDistance && pinchInitialZoom!=null){const pts=Array.from(pointerMap.values()); const curDist=distance(pts[0],pts[1]); if(curDist>0){zoomFactor=Math.max(0.125, Math.min(10, pinchInitialZoom*curDist/pinchInitialDistance)); scheduleRender();} ev.preventDefault && ev.preventDefault();}}, {passive:false});
  window.addEventListener('pointerup',ev=>{if(ev.pointerType!=='touch') return; pointerMap.delete(ev.pointerId); if(pointerMap.size<2){pinchInitialDistance=null; pinchInitialZoom=null; if(currentPdfDoc) renderPdfDocument(currentPdfDoc);}});
  window.addEventListener('pointercancel',ev=>{pointerMap.delete(ev.pointerId); pinchInitialDistance=null; pinchInitialZoom=null;});
}

let scrollTimeout = null;
content.addEventListener('scroll', () => {
    if (scrollTimeout) clearTimeout(scrollTimeout);
    scrollTimeout = setTimeout(() => {
        const scrollTop = content.scrollTop;
        const innerHeight = content.clientHeight;
        const canvases = Array.from(content.querySelectorAll('.page-canvas'));

        // Determine which PDF is currently at the center of viewport
        let minDist = Infinity;
        let currentPdfIndex = null;
        let firstCanvasOfCurrent = null;
        let lastCanvasOfCurrent = null;

        canvases.forEach(canvas => {
            const canvasTop = canvas.offsetTop;
            const canvasCenter = canvasTop + canvas.height / 2;
            const dist = Math.abs(canvasCenter - (scrollTop + innerHeight / 2));
            if (dist < minDist) {
                minDist = dist;
                currentPdfIndex = parseInt(canvas.dataset.pdfIndex);
            }
        });

        if (currentPdfIndex === null) return;

        // Highlight sidebar entry
        pdfList.querySelectorAll('li').forEach((li, idx) => {
            li.classList.toggle('active', idx === currentPdfIndex);
        });

        // Get first and last canvas of current PDF
        const currentCanvases = canvases.filter(c => parseInt(c.dataset.pdfIndex) === currentPdfIndex);
        if (currentCanvases.length) {
            firstCanvasOfCurrent = currentCanvases[0];
            lastCanvasOfCurrent = currentCanvases[currentCanvases.length - 1];
        }

        const neighborIndices = [currentPdfIndex - 1, currentPdfIndex + 1].filter(idx => idx >= 0 && idx < pdfIndexData.length);

        neighborIndices.forEach(idx => {
    const entry = pdfIndexData[idx];
    const hasCanvases = Array.from(content.querySelectorAll('.page-canvas'))
    .some(c => parseInt(c.dataset.pdfIndex) === idx);

        if (!hasCanvases) {
        renderPdfDocument(entry, { append: false }).then(newCanvases => {
          console.log("criou"+idx)
            if (idx < currentPdfIndex && firstCanvasOfCurrent) {
                newCanvases.forEach(c => content.insertBefore(c, firstCanvasOfCurrent));
            } else if (idx > currentPdfIndex && lastCanvasOfCurrent) {
                newCanvases.forEach(c => content.insertBefore(c, lastCanvasOfCurrent.nextSibling));
            }
        }).catch(console.error);
    }
});


        // Remove non-neighbors
        const activeIndices = [currentPdfIndex, ...neighborIndices];
        Array.from(content.querySelectorAll('.page-canvas')).forEach(canvas => {
            const idx = parseInt(canvas.dataset.pdfIndex);
            if (!activeIndices.includes(idx)) {
              console.log("remove"+idx)
              canvas.remove();
            }
        });

    





    }, 50); // debounce scroll
});


const SCROLL_GAP = 1; // keep 1px above bottom
let overscrollCounter = 0;
let lastOverscrollTime = 0;
const OVERSCROLL_THRESHOLD = 4;
const OVERSCROLL_DEBOUNCE = 100;

content.addEventListener('scroll', () => {
  const lastPdfIndex = pdfIndexData.length - 1;
  const lastCanvases = content.querySelectorAll(`.page-canvas[data-pdf-index='${lastPdfIndex}']`);
  const lastCanvas = lastCanvases[lastCanvases.length - 1];
  if (!lastCanvas) return; // SAFEGUARD: must exist

  const canvasBottom = lastCanvas.offsetTop + lastCanvas.clientHeight;
  const viewportBottom = content.scrollTop + content.clientHeight;

  // Only trigger rebound if at the very last canvas
  if (viewportBottom >= canvasBottom) {
    const now = Date.now();

    // Rebound scroll slightly so scroll events continue firing
    const maxScroll = content.scrollHeight - content.clientHeight;
    if (content.scrollTop >= maxScroll) {
      content.scrollTop = maxScroll - SCROLL_GAP;
    }

    // Count overscroll attempts
    if (now - lastOverscrollTime <= OVERSCROLL_DEBOUNCE) overscrollCounter++;
    else overscrollCounter = 1;
    lastOverscrollTime = now;

    if (overscrollCounter >= OVERSCROLL_THRESHOLD) {
      reviewPopup.style.display = 'flex';
    }
  } else {
    // Not at last page → reset
    overscrollCounter = 0;
    reviewPopup.style.display = 'none';
  }
});


</script>
</body>
</html>



